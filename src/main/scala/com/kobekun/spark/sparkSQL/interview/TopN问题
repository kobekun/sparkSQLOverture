

10亿个数中找出最大的10000个数（top K问题）

    优化的方法：可以把所有10亿个数据分组存放，比如分别放在1000个文件中。这样处理就可以分别在每个文件的10^6个数据中找出最大的10000
    个数，合并到一起在再找出最终的结果。

 在大规模数据处理中，经常会遇到的一类问题：在海量数据中找出出现频率最好的前k个数，或者
 从海量数据中找出最大的前k个数，这类问题通常被称为top K问题。例如，在搜索引擎中，统计
 搜索最热门的10个查询词；在歌曲库中统计下载最高的前10首歌等。
 
针对top K类问题，通常比较好的方案是分治+Trie树/hash+小顶堆（就是上面提到的最小堆）
，即先将数据集按照Hash方法分解成多个小数据集，然后使用Trie树活着Hash统计每个小数据集中
的query词频，之后用小顶堆求出每个数据集中出现频率最高的前K个数，最后在所有top K中求出
最终的top K。

有1亿个浮点数，如果找出期中最大的10000个？

1、内存足够将数据全部排序，方法并不高效
2、局部淘汰法
    该方法与排序方法类似，用一个容器保存前10000个数，然后将剩余的所有数字——与容器内的
    最小数字相比，如果某一后续元素比容器内最小数字大，则删掉容器内最小元素，并将该元素插
    入容器，最后遍历完这1亿个数，得到的结果容器中保存的数即为最终结果
3、分治法  *****
    将1亿个数据分成100份，每份100万个数据，找到每份数据中最大的10000个，最后在剩下的
    100*10000个数据里面找出最大的10000个。
    100万个数据里面查找最大的10000个数据的方法如下：用快速排序的方法，将数据分为2堆，
    如果大的那堆个数N大于10000个，继续对大堆快速排序一次分成2堆，如果大的那堆个数N
    大于10000个，继续对大堆快速排序一次分成2堆，如果大堆个数N小于10000个，就在小的
    那堆里面快速排序一次，找第10000-n大的数字；递归以上过程，就可以找到第1w大的数。

4、hash
    如果这1亿个书里面有很多重复的数，先通过Hash法，把这1亿个数字去重复，这样如果重复率
    很高的话，会减少很大的内存用量，从而缩小运算空间，然后通过分治法或最小堆法查找最大
    的10000个数
5、最小堆
    首先读入前10000个数来创建大小为10000的最小堆，建堆的时间复杂度为O（mlogm）
    （m为数组的大小即为10000），然后遍历后续的数字，并于堆顶（最小）数字进行比较。
    如果比最小的数小，则继续读取后续数字；如果比堆顶数字大，则替换堆顶元素并重新调整
    堆为最小堆。整个过程直至1亿个数全部遍历完为止。

以下是一些经常被提及的该类问题。
（1）有10000000个记录，这些查询串的重复度比较高，如果除去重复后，不超过3000000个。
    一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。请统计最热门的10个
    查询串，要求使用的内存不能超过1GB。

（2）有10个文件，每个文件1GB，每个文件的每一行存放的都是用户的query，每个文件的query
    都可能重复。按照query的频度排序。

（3）有一个1GB大小的文件，里面的每一行是一个词，词的大小不超过16个字节，内存限制大小
    是1MB。返回频数最高的100个词。

（4）提取某日访问网站次数最多的那个IP。

（5）10亿个整数找出重复次数最多的100个整数。

（6）搜索的输入信息是一个字符串，统计300万条输入信息中最热门的前10条，每次输入的一个
    字符串为不超过255B，内存使用只有1GB。

（7）有1000万个身份证号以及他们对应的数据，身份证号可能重复，找出出现次数最多的身份证号。














