
持久化级别：

    MEMORY_ONLY

        使用未序列化的java对象格式，将数据保存在内存中。如果内存不够存放所有的数据，那么数据
        可能就不会进行持久化。下次对这个rdd执行算子操作时，没有被持久化的数据就会重新从源头
        计算。
        这是默认的持久化策略。cache()使用就是这种策略

    MEMORY_AND_DISK

        使用未序列化的java对象格式，优先尝试将数据保存在内存中。如果内存不够存放所有的数据
        会将数据写入到磁盘中，下次对这个rdd执行算子时，持久化在磁盘中的数据会被读取出来使用

    MEMORY_ONLY_SER

        含义和MEMORY_ONLY一样，只是需要将数据序列化，将rdd每个partition中数据序列化成字节
        数组，这种方式更省内存，从而避免持久化的数据过多占用过多内存导致GC

    MEMORY_AND_DISK_SER

        含义同MEMORY_AND_DISK，也是需要将数据序列化成字节数组，以避免数据过多占用过多内存

    DISK_ONLY

        将数据全部写入到磁盘中

    MEMORY_ONLY_2, MEMORY_AND_DISK_2, 。。。

        将持久化的数据都复制一个副本，把该副本保存到别的节点中。后续对rdd的计算可以使用
        该副本，保证容错


 选择合适的持久化策略

    1) 默认情况下，性能最高是MEMORY_ONLY，如果内存足够大，可以绰绰有余的放下所有rdd的数据
    a、不需要序列化和反序列化操作，避免了这部分的性能开销
    b、rdd的后续算子操作，都是基于存内存的数据操作，不需要从磁盘中取数据
    c、不需要复制副本

    此种情况实际生产中用的很有限，如果rdd数据比较多(比如几十亿)，直接用这种持久化级别，会
    导致内存溢出(OOM)

    2) 如果使用MEMORY_ONLY_SER，该级别会将rdd数据序列化后再保存在内存中，
    由于每个partition仅仅是一个字节数组，对象数量大大减少，减少了内存使用，这种级别相比
    MEMORY_ONLY，只是多出了序列化和反序列化的开销。后续进行的内存中算子操作，性能还是比较
    可观的

    3) 如果上面两个都无法使用，建议用MEMORY_AND_DISK_SER。这个级别就说明rdd数据很大，
    先序列化数据到内存，内存放不下，放到磁盘。

    4) 不建议使用DISK_ONLY、_2级别，因为DISK_ONLY完全基于磁盘，性能急剧下降，还不如用时
    重新计算用的rdd。_2级别复制副本到别的节点，数据复制和网络传输会导致较大的性能开销，除非
    要求作业的高可用性

























